type: update
id: docker-swarm-init
name: Docker Swarm Init

onInstall:
  #blocking requests to the old swarm
  - if ("${settings.oldIntIPs:}"):
      nat: A
  - env.control.ExecDockerRunCmd[*]
  - log: Swarm Init
  - init-swarm
  #giving some time for cluster recovery after clone 
  - if ("${settings.oldIntIPs:}" && nodes.cp.length > 1): 
      sleep: 10000
  - build-cluster
  #rejoining master manager for udating --advertise-addr  
  - if ("${settings.oldIntIPs:}" && nodes.cp.length > 1):
      - cmd[${nodes.cp.master.id}]: |-
          docker swarm leave --force &>> /var/log/run.log
          docker swarm join --token ${globals.manager-token} ${nodes.cp.last.intIP}:2377 >> /var/log/run.log
      - nat: D

onAfterScaleOut[worker]:
  - get-ids: event.response.nodes
  - get-worker-token
  - connectNode: 
      id: ${globals.ids}
      token: ${globals.worker-token}

onAfterScaleOut[cp]:
  - get-ids: event.response.nodes
  - get-manager-token
  - connectNode: 
      id: ${globals.ids}
      token: ${globals.manager-token}

onBeforeScaleIn[cp]:
  - get-ids: event.response.nodes
  - removeNode:
      id: ${globals.ids}

onBeforeScaleIn[worker]:
  - get-ids: event.response.nodes
  - removeNode:
      id: ${globals.ids}

actions:
  nat:
    cmd[cp,worker]: |-
      IFS=',' read -ra ips <<< ${settings.oldIntIPs:}
      for ip in "${ips[@]}"; do
        iptables -t nat -${this} OUTPUT -p tcp -d $ip -j DNAT --to-destination ${nodes.cp.master.intIP}  
      done
  
  init-swarm:
    cmd[${nodes.cp.master.id}]: |-
      echo -e "\n\n-------------\n$(date) -> Init Swarm: --force-new-cluster --advertise-addr ${nodes.cp.master.intIP}" >> /var/log/run.log
      docker swarm init --force-new-cluster --advertise-addr ${nodes.cp.master.intIP} >> /var/log/run.log
      nodes=$(docker node ls | awk '/Down|Unknown/' | awk '{print $1}')
      for n in $nodes; do docker node rm $n; done    
      
  get-ids:
    - setGlobals: 
        ids: ''
        sep: ''
    - forEach(${this}):
        if (${@i.id} != ${nodes.cp.master.id}):
          add-id: ${@i.id}

  add-id:
    setGlobals: 
      ids: ${globals.ids:}${globals.sep:}${this}
      sep: ','
      
  build-cluster:    
    - log: Connecting Manager Nodes
    - get-ids: nodes.cp
    - get-manager-token
    #extra 'swarm leave' - workaround against sporadic after clone 'Error response from daemon: context deadline exceeded'
    - if ("${settings.oldIntIPs:}"):
        cmd[${globals.ids}]: docker swarm leave --force &>> /var/log/run.log || echo "LEAVE ERROR: check /var/log/run.log"
    - connectNode: 
        id: ${globals.ids}
        token: ${globals.manager-token}
        
    - log: Connecting Worker Nodes
    - get-worker-token
    - connectNode: 
        id: worker
        token: ${globals.worker-token}
     
  get-manager-token: 
    - cmd[${nodes.cp.master.id}]: docker swarm join-token -q manager
    - setGlobals:
        manager-token: ${response.out}
        
  get-worker-token: 
    - cmd[${nodes.cp.master.id}]: docker swarm join-token -q worker
    - setGlobals:
        worker-token: ${response.out}
  
  connectNode:
    cmd[${this.id}]: |-
      docker swarm leave --force &>> /var/log/run.log
      docker swarm join --token ${this.token} ${nodes.cp.master.intIP}:2377 &>> /var/log/run.log || echo "JOIN ERROR: check /var/log/run.log"
    
  removeNode:
    - cmd[${nodes.cp.master.id}]: |-
        IFS=',' read -ra node <<< ${this.id}
        for id in "${node[@]}"; do
          docker node demote node$id-${env.domain} &>> /var/log/run.log
        done
    - cmd[${this.id}]: docker swarm leave --force &>> /var/log/run.log
    - cmd[${nodes.cp.master.id}]: |-
        IFS=',' read -ra node <<< ${this.id}
        for id in "${node[@]}"; do
          docker node rm --force node$id-${env.domain} &>> /var/log/run.log    
        done
